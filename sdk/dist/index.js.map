{"version":3,"sources":["../src/core/crypto.ts","../src/intent/index.ts","../src/client.ts","../src/engine/index.ts","../src/chain/builders.ts","../src/chain/discriminator.ts","../src/chain/bytes.ts","../src/chain/pdas.ts","../src/chain/layout.ts","../src/constants.ts","../src/client/pay.ts"],"sourcesContent":["export async function sha256Hash(\n  input: string | Uint8Array\n): Promise<Uint8Array> {\n  const data =\n    typeof input === \"string\"\n      ? new TextEncoder().encode(input)\n      : input;\n\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", data);\n  return new Uint8Array(hashBuffer);\n}\n","import type { IntentInput, Intent } from \"../core/types.js\";\nimport { sha256Hash } from \"../core/crypto.js\";\nimport { PublicKey } from \"@solana/web3.js\";\n\nexport async function createIntent(\n  input: IntentInput,\n  payer: PublicKey\n): Promise<Intent> {\n  if (input.amount <= 0) {\n    throw new Error(\"Invalid amount\");\n  }\n\n  const payload = {\n    token: input.token,\n    amount: input.amount,\n    merchant: input.merchant.toBase58(),\n    payer: payer.toBase58(),\n    reference: input.reference ?? null,\n    metadata: input.metadata ?? null,\n    nonce: crypto.randomUUID(),\n    createdAt: Date.now(),\n  };\n\n  const canonical = JSON.stringify(payload);\n  const hash = await sha256Hash(canonical);\n\n  return {\n    id: payload.nonce,\n    hash,\n    createdAt: payload.createdAt,\n    payer,\n  };\n}\n","import type { SDKConfig, IntentInput, Intent } from \"./core/types.js\";\nimport * as intent from \"./intent/index.js\";\n\nexport class Intentis {\n  constructor(private readonly config: SDKConfig) {}\n\n  intent = {\n    create: (input: IntentInput): Promise<Intent> =>\n      intent.createIntent(input, this.config.wallet.publicKey),\n  };\n\n  async pay(): Promise<unknown> {\n    throw new Error(\"Not implemented: pay\");\n  }\n\n  async disclose(): Promise<unknown> {\n    throw new Error(\"Not implemented: disclose\");\n  }\n}\n","import type { Intent } from \"../core/types.js\";\nimport { sha256Hash } from \"../core/crypto.js\";\n\nexport async function execute(\n  intent: Intent\n): Promise<{ proofHash: Uint8Array }> {\n  const payload = new Uint8Array([\n    ...intent.hash,\n    ...new TextEncoder().encode(Date.now().toString()),\n  ]);\n\n  const proofHash = await sha256Hash(payload);\n  return { proofHash };\n}\n","import {\n  Connection,\n  PublicKey,\n  SystemProgram,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\n\nimport { anchorDiscriminator } from \"./discriminator.js\";\nimport { concatBytes } from \"./bytes.js\";\nimport {\n  deriveIntentPda,\n  deriveReceiptPda,\n  deriveDisclosurePda,\n} from \"./pdas.js\";\nimport {\n  encodeSettleArgs,\n  encodeDiscloseArgs,\n} from \"./layout.js\";\n\nexport async function buildSettleIntentTx(params: {\n  connection: Connection;\n  programId: PublicKey;\n  payer: PublicKey;\n  intentHash: Uint8Array;\n  proofHash: Uint8Array;\n}): Promise<{\n  tx: Transaction;\n  intentPda: PublicKey;\n  receiptPda: PublicKey;\n}> {\n  const {\n    connection,\n    programId,\n    payer,\n    intentHash,\n    proofHash,\n  } = params;\n\n  const intentPda = deriveIntentPda(programId, intentHash);\n  const receiptPda = deriveReceiptPda(programId, intentPda);\n\n  const discriminator = await anchorDiscriminator(\"settle_intent\");\n  const args = encodeSettleArgs(proofHash);\n  const data = Buffer.from(concatBytes(discriminator, args));\n\n  const ix = new TransactionInstruction({\n    programId,\n    keys: [\n      { pubkey: intentPda, isSigner: false, isWritable: true },\n      { pubkey: receiptPda, isSigner: false, isWritable: true },\n      { pubkey: payer, isSigner: true, isWritable: true }, // authority\n      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },\n    ],\n    data,\n  });\n\n  const { blockhash } = await connection.getLatestBlockhash(\"confirmed\");\n\n  const tx = new Transaction({\n    feePayer: payer,\n    recentBlockhash: blockhash,\n  }).add(ix);\n\n  return { tx, intentPda, receiptPda };\n}\n\nexport async function buildDiscloseTx(params: {\n  connection: Connection;\n  programId: PublicKey;\n  payer: PublicKey;\n  intentHash: Uint8Array;\n  disclosureHash: Uint8Array;\n}): Promise<{\n  tx: Transaction;\n  disclosurePda: PublicKey;\n}> {\n  const {\n    connection,\n    programId,\n    payer,\n    intentHash,\n    disclosureHash,\n  } = params;\n\n  const intentPda = deriveIntentPda(programId, intentHash);\n  const disclosurePda = deriveDisclosurePda(\n    programId,\n    intentPda,\n    disclosureHash\n  );\n\n  const discriminator = await anchorDiscriminator(\"disclose\");\n  const args = encodeDiscloseArgs(disclosureHash);\n  const data = Buffer.from(concatBytes(discriminator, args));\n\n  const ix = new TransactionInstruction({\n    programId,\n    keys: [\n      { pubkey: disclosurePda, isSigner: false, isWritable: true },\n      { pubkey: payer, isSigner: true, isWritable: true },\n      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },\n    ],\n    data,\n  });\n\n  const { blockhash } = await connection.getLatestBlockhash(\"confirmed\");\n\n  const tx = new Transaction({\n    feePayer: payer,\n    recentBlockhash: blockhash,\n  }).add(ix);\n\n  return { tx, disclosurePda };\n}\n","import { sha256Hash } from \"../core/crypto.js\";\n\nexport async function anchorDiscriminator(name: string): Promise<Uint8Array> {\n  // Anchor: first 8 bytes of sha256(\"global:<name>\")\n  const preimage = `global:${name}`;\n  const hash = await sha256Hash(preimage);\n  return hash.slice(0, 8);\n}\n","export function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const length = arrays.reduce((sum, a) => sum + a.length, 0);\n  const result = new Uint8Array(length);\n  let offset = 0;\n\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n\n  return result;\n}\n","import { PublicKey } from \"@solana/web3.js\";\n\nconst encoder = new TextEncoder();\n\nexport function deriveIntentPda(\n  programId: PublicKey,\n  intentHash: Uint8Array\n): PublicKey {\n  const [pda] = PublicKey.findProgramAddressSync(\n    [encoder.encode(\"intent\"), intentHash],\n    programId\n  );\n  return pda;\n}\n\nexport function deriveReceiptPda(\n  programId: PublicKey,\n  intentPda: PublicKey\n): PublicKey {\n  const [pda] = PublicKey.findProgramAddressSync(\n    [encoder.encode(\"receipt\"), intentPda.toBuffer()],\n    programId\n  );\n  return pda;\n}\n\nexport function deriveDisclosurePda(\n  programId: PublicKey,\n  intentPda: PublicKey,\n  disclosureHash: Uint8Array\n): PublicKey {\n  const [pda] = PublicKey.findProgramAddressSync(\n    [encoder.encode(\"disclosure\"), intentPda.toBuffer(), disclosureHash],\n    programId\n  );\n  return pda;\n}\n","/**\n * Anchor settle_intent args:\n * - execution_proof_hash: [u8; 32]\n */\nexport function encodeSettleArgs(\n  proofHash: Uint8Array\n): Uint8Array {\n  if (proofHash.length !== 32) {\n    throw new Error(\"execution_proof_hash must be 32 bytes\");\n  }\n  return proofHash;\n}\n\n/**\n * Anchor disclose args (si applicable)\n * - disclosure_hash: [u8; 32]\n */\nexport function encodeDiscloseArgs(\n  disclosureHash: Uint8Array\n): Uint8Array {\n  if (disclosureHash.length !== 32) {\n    throw new Error(\"disclosure_hash must be 32 bytes\");\n  }\n  return disclosureHash;\n}\n","import { PublicKey } from \"@solana/web3.js\";\n\nexport const DEVNET_PROGRAM_ID = new PublicKey(\n  \"DD9vD79VgN3FbwSfpsxfB12ZRZeJtNYpeUT6FhJPZ315\"\n);\n","import { Connection, PublicKey, Transaction } from \"@solana/web3.js\";\n\nimport type { Intent } from \"../core/types.js\";\nimport { execute } from \"../engine/index.js\";\nimport { buildSettleIntentTx } from \"../chain/builders.js\";\nimport { DEVNET_PROGRAM_ID } from \"../constants.js\";\n\nexport async function pay(params: {\n  connection: Connection;\n  payer: PublicKey;\n  intent: Intent;\n}): Promise<{\n  transaction: Transaction;\n  intentPda: PublicKey;\n  receiptPda: PublicKey;\n}> {\n  const { connection, payer, intent } = params;\n\n  const programId = DEVNET_PROGRAM_ID;\n\n  const { proofHash } = await execute(intent);\n\n  const { tx, intentPda, receiptPda } =\n    await buildSettleIntentTx({\n      connection,\n      programId,\n      payer,\n      intentHash: intent.hash,\n      proofHash,\n    });\n\n  return {\n    transaction: tx,\n    intentPda,\n    receiptPda,\n  };\n}\n"],"mappings":"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","names":["PublicKey"]}